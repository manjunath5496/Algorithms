<p>In&nbsp;<a title="Mathematics" href="https://en.wikipedia.org/wiki/Mathematics">mathematics</a>&nbsp;and&nbsp;<a title="Computer science" href="https://en.wikipedia.org/wiki/Computer_science">computer science</a>, an&nbsp;<strong>algorithm</strong>&nbsp;is a finite sequence of&nbsp;<a title="Well-defined" href="https://en.wikipedia.org/wiki/Well-defined">well-defined</a>, computer-implementable instructions, typically to solve a class of problems or to perform a computation.&nbsp;Algorithms are always&nbsp;<a class="mw-redirect" title="Unambiguous" href="https://en.wikipedia.org/wiki/Unambiguous">unambiguous</a>&nbsp;and are used as specifications for performing&nbsp;<a title="Calculation" href="https://en.wikipedia.org/wiki/Calculation">calculations</a>,&nbsp;<a title="Data processing" href="https://en.wikipedia.org/wiki/Data_processing">data processing</a>,&nbsp;<a title="Automated reasoning" href="https://en.wikipedia.org/wiki/Automated_reasoning">automated reasoning</a>, and other tasks.</p>
<p>As an&nbsp;<a title="Effective method" href="https://en.wikipedia.org/wiki/Effective_method">effective method</a>, an algorithm can be expressed within a finite amount of space and time,&nbsp;and in a well-defined formal language&nbsp;for calculating a&nbsp;<a title="Function (mathematics)" href="https://en.wikipedia.org/wiki/Function_(mathematics)">function</a>.&nbsp;Starting from an initial state and initial input (perhaps&nbsp;<a title="Empty string" href="https://en.wikipedia.org/wiki/Empty_string">empty</a>),&nbsp;the instructions describe a&nbsp;<a title="Computation" href="https://en.wikipedia.org/wiki/Computation">computation</a>&nbsp;that, when&nbsp;<a title="Execution (computing)" href="https://en.wikipedia.org/wiki/Execution_(computing)">executed</a>, proceeds through a finite&nbsp;number of well-defined successive states, eventually producing "output"&nbsp;and terminating at a final ending state. The transition from one state to the next is not necessarily&nbsp;<a class="mw-redirect" title="Deterministic" href="https://en.wikipedia.org/wiki/Deterministic">deterministic</a>; some algorithms, known as&nbsp;<a class="mw-redirect" title="Randomized algorithms" href="https://en.wikipedia.org/wiki/Randomized_algorithms">randomized algorithms</a>, incorporate random input.</p>
<p>The concept of algorithm has existed since antiquity.&nbsp;<a title="Arithmetic" href="https://en.wikipedia.org/wiki/Arithmetic">Arithmetic</a>&nbsp;algorithms, such as a&nbsp;<a title="Division algorithm" href="https://en.wikipedia.org/wiki/Division_algorithm">division algorithm</a>, was used by ancient&nbsp;<a title="Babylonian mathematics" href="https://en.wikipedia.org/wiki/Babylonian_mathematics">Babylonian mathematicians</a>&nbsp;c. 2500 BC and&nbsp;<a class="mw-redirect" title="Egyptian mathematics" href="https://en.wikipedia.org/wiki/Egyptian_mathematics">Egyptian mathematicians</a>&nbsp;c. 1550 BC.&nbsp;<a title="Greek mathematics" href="https://en.wikipedia.org/wiki/Greek_mathematics">Greek mathematicians</a>&nbsp;later used algorithms in the&nbsp;<a title="Sieve of Eratosthenes" href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">sieve of Eratosthenes</a>&nbsp;for finding prime numbers,&nbsp;and the&nbsp;<a title="Euclidean algorithm" href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Euclidean algorithm</a>&nbsp;for finding the&nbsp;<a title="Greatest common divisor" href="https://en.wikipedia.org/wiki/Greatest_common_divisor">greatest common divisor</a>&nbsp;of two numbers.&nbsp;<a class="mw-redirect" title="Arabic mathematics" href="https://en.wikipedia.org/wiki/Arabic_mathematics">Arabic mathematicians</a>&nbsp;such as&nbsp;<a title="Al-Kindi" href="https://en.wikipedia.org/wiki/Al-Kindi">Al-Kindi</a>&nbsp;in the 9th century used&nbsp;<a class="mw-redirect" title="Cryptographic" href="https://en.wikipedia.org/wiki/Cryptographic">cryptographic</a>&nbsp;algorithms for&nbsp;<a class="mw-redirect" title="Code-breaking" href="https://en.wikipedia.org/wiki/Code-breaking">code-breaking</a>, based on&nbsp;<a title="Frequency analysis" href="https://en.wikipedia.org/wiki/Frequency_analysis">frequency analysis</a>.</p>
<p>The word&nbsp;<em>algorithm</em>&nbsp;itself is derived from the 9th-century&nbsp;<a class="mw-redirect" title="Persian people" href="https://en.wikipedia.org/wiki/Persian_people">Persian</a>&nbsp;mathematician&nbsp;<a title="Muhammad ibn Musa al-Khwarizmi" href="https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi">Muḥammad ibn Mūsā al-Khwārizmī</a>, Latinized&nbsp;<em>Algoritmi</em>.&nbsp;A partial formalization of what would become the modern concept of algorithm began with attempts to solve the&nbsp;<a title="Entscheidungsproblem" href="https://en.wikipedia.org/wiki/Entscheidungsproblem">Entscheidungsproblem</a>&nbsp;(decision problem) posed by&nbsp;<a title="David Hilbert" href="https://en.wikipedia.org/wiki/David_Hilbert">David Hilbert</a>&nbsp;in 1928. Later formalizations were framed as attempts to define "<a class="mw-redirect" title="Effective calculability" href="https://en.wikipedia.org/wiki/Effective_calculability">effective calculability</a>"&nbsp;or "effective method".<sup id="cite_ref-16" class="reference"><a href="https://en.wikipedia.org/wiki/Algorithm#cite_note-16">[16]</a></sup>&nbsp;Those formalizations included the&nbsp;<a title="Kurt G&ouml;del" href="https://en.wikipedia.org/wiki/Kurt_G%C3%B6del">G&ouml;del</a>&ndash;<a title="Jacques Herbrand" href="https://en.wikipedia.org/wiki/Jacques_Herbrand">Herbrand</a>&ndash;<a title="Stephen Cole Kleene" href="https://en.wikipedia.org/wiki/Stephen_Cole_Kleene">Kleene</a>&nbsp;<a title="Recursion (computer science)" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)">recursive functions</a>&nbsp;of 1930, 1934 and 1935,&nbsp;<a title="Alonzo Church" href="https://en.wikipedia.org/wiki/Alonzo_Church">Alonzo Church</a>'s&nbsp;<a title="Lambda calculus" href="https://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a>&nbsp;of 1936,&nbsp;<a class="mw-redirect" title="Emil Post" href="https://en.wikipedia.org/wiki/Emil_Post">Emil Post</a>'s&nbsp;<a class="mw-redirect" title="Formulation 1" href="https://en.wikipedia.org/wiki/Formulation_1">Formulation 1</a>&nbsp;of 1936, and&nbsp;<a title="Alan Turing" href="https://en.wikipedia.org/wiki/Alan_Turing">Alan Turing</a>'s&nbsp;<a class="mw-redirect" title="Turing machines" href="https://en.wikipedia.org/wiki/Turing_machines">Turing machines</a>&nbsp;of 1936&ndash;37 and 1939.</p>

</br>

<p><strong>Contents</strong></p>
<div class="toctitle" dir="ltr" lang="en">&nbsp;</div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Etymology"><span class="toctext">Etymology</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Informal_definition"><span class="toctext">Informal definition</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Formalization"><span class="toctext">Formalization</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Expressing_algorithms"><span class="toctext">Expressing algorithms</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="#Design"><span class="toctext">Design</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Implementation"><span class="toctext">Implementation</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Computer_algorithms"><span class="toctext">Computer algorithms</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#Examples"><span class="toctext">Examples</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#Algorithm_example"><span class="toctext">Algorithm example</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Euclid's_algorithm"><span class="toctext">Euclid's algorithm</span></a>
<ul>
<li class="toclevel-3 tocsection-11"><a href="#Computer_language_for_Euclid's_algorithm"><span class="toctext">Computer language for Euclid's algorithm</span></a></li>
<li class="toclevel-3 tocsection-12"><a href="#An_inelegant_program_for_Euclid's_algorithm"><span class="toctext">An inelegant program for Euclid's algorithm</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="#An_elegant_program_for_Euclid's_algorithm"><span class="toctext">An elegant program for Euclid's algorithm</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-14"><a href="#Testing_the_Euclid_algorithms"><span class="toctext">Testing the Euclid algorithms</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Measuring_and_improving_the_Euclid_algorithms"><span class="toctext">Measuring and improving the Euclid algorithms</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-16"><a href="#Algorithmic_analysis"><span class="toctext">Algorithmic analysis</span></a>
<ul>
<li class="toclevel-2 tocsection-17"><a href="#Formal_versus_empirical"><span class="toctext">Formal versus empirical</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Execution_efficiency"><span class="toctext">Execution efficiency</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="#Classification"><span class="toctext">Classification</span></a>
<ul>
<li class="toclevel-2 tocsection-20"><a href="#By_implementation"><span class="toctext">By implementation</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#By_design_paradigm"><span class="toctext">By design paradigm</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="#Optimization_problems"><span class="toctext">Optimization problems</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#By_field_of_study"><span class="toctext">By field of study</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#By_complexity"><span class="toctext">By complexity</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-25"><a href="#Continuous_algorithms"><span class="toctext">Continuous algorithms</span></a></li>
<li class="toclevel-1 tocsection-26"><a href="#Legal_issues"><span class="toctext">Legal issues</span></a></li>
<li class="toclevel-1 tocsection-27"><a href="#History:_Development_of_the_notion_of_%22algorithm%22"><span class="toctext">History: Development of the notion of "algorithm"</span></a>
<ul>
<li class="toclevel-2 tocsection-28"><a href="#Ancient_Near_East"><span class="toctext">Ancient Near East</span></a></li>
<li class="toclevel-2 tocsection-29"><a href="#Discrete_and_distinguishable_symbols"><span class="toctext">Discrete and distinguishable symbols</span></a></li>
<li class="toclevel-2 tocsection-30"><a href="#Manipulation_of_symbols_as_%22place_holders%22_for_numbers:_algebra"><span class="toctext">Manipulation of symbols as "place holders" for numbers: algebra</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="#Cryptographic_algorithms"><span class="toctext">Cryptographic algorithms</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="#Mechanical_contrivances_with_discrete_states"><span class="toctext">Mechanical contrivances with discrete states</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#Mathematics_during_the_19th_century_up_to_the_mid-20th_century"><span class="toctext">Mathematics during the 19th century up to the mid-20th century</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#Emil_Post_(1936)_and_Alan_Turing_(1936%E2%80%9337,_1939)"><span class="toctext">Emil Post (1936) and Alan Turing (1936&ndash;37, 1939)</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="#J.B._Rosser_(1939)_and_S.C._Kleene_(1943)"><span class="toctext">J.B. Rosser (1939) and S.C. Kleene (1943)</span></a></li>
<li class="toclevel-2 tocsection-36"><a href="#History_after_1950"><span class="toctext">History after 1950</span></a></li>
</ul>
</li>
</ul>
</br>

<h2><span id="Etymology" class="mw-headline">Etymology</span></h2>
<p>The word 'algorithm' has its roots in Latinizing the name of Persian mathematician&nbsp;<a title="Muhammad ibn Musa al-Khwarizmi" href="https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi">Muhammad ibn Musa al-Khwarizmi</a>&nbsp;in the first steps to&nbsp;<em>algorismus</em>.&nbsp;Al-Khwārizmī (<a title="Persian language" href="https://en.wikipedia.org/wiki/Persian_language">Persian</a>:&nbsp;<span dir="rtl" lang="fa">خوارزمی</span>&lrm;, c. 780&ndash;850) was a Persian mathematician,&nbsp;<a title="Astronomer" href="https://en.wikipedia.org/wiki/Astronomer">astronomer</a>,&nbsp;<a title="Geographer" href="https://en.wikipedia.org/wiki/Geographer">geographer</a>, and scholar in the&nbsp;<a title="House of Wisdom" href="https://en.wikipedia.org/wiki/House_of_Wisdom">House of Wisdom</a>&nbsp;in&nbsp;<a title="Baghdad" href="https://en.wikipedia.org/wiki/Baghdad">Baghdad</a>,&nbsp;whose name means 'the native of&nbsp;<a title="Khwarazm" href="https://en.wikipedia.org/wiki/Khwarazm">Khwarazm</a>', a region that was part of&nbsp;<a title="Greater Iran" href="https://en.wikipedia.org/wiki/Greater_Iran">Greater Iran</a>&nbsp;and is now in&nbsp;<a title="Uzbekistan" href="https://en.wikipedia.org/wiki/Uzbekistan">Uzbekistan</a>.</p>
<p>About 825, al-Khwarizmi wrote an&nbsp;<a class="mw-redirect" title="Arabic language" href="https://en.wikipedia.org/wiki/Arabic_language">Arabic language</a>&nbsp;treatise on the&nbsp;<a title="Hindu&ndash;Arabic numeral system" href="https://en.wikipedia.org/wiki/Hindu%E2%80%93Arabic_numeral_system">Hindu&ndash;Arabic numeral system</a>, which was translated into&nbsp;<a title="Latin" href="https://en.wikipedia.org/wiki/Latin">Latin</a>&nbsp;during the 12th century under the title&nbsp;<em>Algoritmi de numero Indorum</em>. This title means "Algoritmi on the numbers of the Indians", where "Algoritmi" was the translator's&nbsp;<a title="Latinisation of names" href="https://en.wikipedia.org/wiki/Latinisation_of_names">Latinization</a>&nbsp;of Al-Khwarizmi's name.&nbsp;Al-Khwarizmi was the most widely read mathematician in Europe in the late Middle Ages, primarily through another of his books, the&nbsp;<a class="mw-redirect" title="Al-Jabr" href="https://en.wikipedia.org/wiki/Al-Jabr">Algebra</a>. In late medieval Latin,&nbsp;<em>algorismus</em>, English '<a title="Algorism" href="https://en.wikipedia.org/wiki/Algorism">algorism</a>', the corruption of his name, simply meant the "decimal number system".&nbsp;In the 15th century, under the influence of the Greek word ἀ&rho;&iota;&theta;&mu;ό&sigmaf; 'number' (<em>cf.</em>&nbsp;'arithmetic'), the Latin word was altered to&nbsp;<em>algorithmus</em>, and the corresponding English term 'algorithm' is first attested in the 17th century; the modern sense was introduced in the 19th century.</p>
<p>In English, it was first used in about 1230 and then by&nbsp;<a title="Geoffrey Chaucer" href="https://en.wikipedia.org/wiki/Geoffrey_Chaucer">Chaucer</a>&nbsp;in 1391. English adopted the French term, but it wasn't until the late 19th century that "algorithm" took on the meaning that it has in modern English.</p>
<p>Another early use of the word is from 1240, in a manual titled&nbsp;<em>Carmen de Algorismo</em>&nbsp;composed by&nbsp;<a title="Alexander of Villedieu" href="https://en.wikipedia.org/wiki/Alexander_of_Villedieu">Alexandre de Villedieu</a>. It begins with:</p>
<blockquote class="templatequote">
<p><em>Haec algorismus ars praesens dicitur, in qua / Talibus Indorum fruimur bis quinque figuris.</em></p>
</blockquote>
<p>which translates to:</p>
<blockquote class="templatequote">
<p>Algorism is the art by which at present we use those Indian figures, which number two times five.</p>
</blockquote>
<p>The poem is a few hundred lines long and summarizes the art of calculating with the new style of Indian dice, or Talibus Indorum, or Hindu numerals.</p>
<h2><span id="Informal_definition" class="mw-headline">Informal definition</span></h2>
<div class="hatnote navigation-not-searchable">For a detailed presentation of the various points of view on the definition of "algorithm", see&nbsp;<a title="Algorithm characterizations" href="https://en.wikipedia.org/wiki/Algorithm_characterizations">Algorithm characterizations</a>.</div>
<p>An informal definition could be "a set of rules that precisely defines a sequence of operations",&nbsp;which would include all computer programs, including programs that do not perform numeric calculations, and (for example) any prescribed&nbsp;<a class="mw-redirect" title="Bureaucratic" href="https://en.wikipedia.org/wiki/Bureaucratic">bureaucratic</a>&nbsp;procedure.&nbsp;In general, a program is only an algorithm if it stops eventually.</p>
<p>A prototypical example of an algorithm is the&nbsp;<a title="Euclidean algorithm" href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Euclidean algorithm</a>, which is used to determine the maximum common divisor of two integers; an example (there are others) is described by the&nbsp;<a title="Flowchart" href="https://en.wikipedia.org/wiki/Flowchart">flowchart</a>&nbsp;above and as an example in a later section.</p>
<p><a href="https://en.wikipedia.org/wiki/Algorithm#CITEREFBoolosJeffrey1999">Boolos, Jeffrey &amp; 1974, 1999</a>&nbsp;offer an informal meaning of the word "algorithm" in the following quotation:</p>
<blockquote>
<p>No human being can write fast enough, or long enough, or small enough&dagger; ( &dagger;"smaller and smaller without limit &hellip; you'd be trying to write on molecules, on atoms, on electrons") to list all members of an enumerably infinite set by writing out their names, one after another, in some notation. But humans can do something equally useful, in the case of certain enumerably infinite sets: They can give&nbsp;<em>explicit instructions for determining the&nbsp;<strong>n</strong>th member of the set</em>, for arbitrary finite&nbsp;<em>n</em>. Such instructions are to be given quite explicitly, in a form in which&nbsp;<em>they could be followed by a computing machine</em>, or by a&nbsp;<em>human who is capable of carrying out only very elementary operations on symbols.</em></p>
</blockquote>
<p>An "<a title="Recursively enumerable set" href="https://en.wikipedia.org/wiki/Recursively_enumerable_set">enumerably infinite set</a>" is one whose elements can be put into one-to-one correspondence with the integers. Thus, Boolos and Jeffrey are saying that an algorithm implies instructions for a process that "creates" output integers from an&nbsp;<em>arbitrary</em>&nbsp;"input" integer or integers that, in theory, can be arbitrarily large. For example, an algorithm can be an algebraic equation such as&nbsp;<em>y = m + n</em>&nbsp;(i.e., two arbitrary "input variables"&nbsp;<em>m</em>&nbsp;and&nbsp;<em>n</em>&nbsp;that produce an output&nbsp;<em>y</em>), but various authors' attempts to define the notion indicate that the word implies much more than this, something on the order of (for the addition example):</p>
<dl>
<dd>Precise instructions (in language understood by "the computer")&nbsp;for a fast, efficient, "good"&nbsp;process that specifies the "moves" of "the computer" (machine or human, equipped with the necessary internally contained information and capabilities)&nbsp;to find, decode, and then process arbitrary input integers/symbols&nbsp;<em>m</em>&nbsp;and&nbsp;<em>n</em>, symbols&nbsp;<em>+</em>&nbsp;and&nbsp;<em>=</em>&nbsp;&hellip; and "effectively"&nbsp;produce, in a "reasonable" time,&nbsp;output-integer&nbsp;<em>y</em>&nbsp;at a specified place and in a specified format.</dd>
</dl>
<p>The concept of&nbsp;<em>algorithm</em>&nbsp;is also used to define the notion of&nbsp;<a title="Decidability (logic)" href="https://en.wikipedia.org/wiki/Decidability_(logic)">decidability</a>&mdash;a notion that is central for explaining how&nbsp;<a title="Formal system" href="https://en.wikipedia.org/wiki/Formal_system">formal systems</a>&nbsp;come into being starting from a small set of&nbsp;<a title="Axiom" href="https://en.wikipedia.org/wiki/Axiom">axioms</a>&nbsp;and rules. In&nbsp;<a title="Logic" href="https://en.wikipedia.org/wiki/Logic">logic</a>, the time that an algorithm requires to complete cannot be measured, as it is not apparently related to the customary physical dimension. From such uncertainties, that characterize ongoing work, stems the unavailability of a definition of&nbsp;<em>algorithm</em>&nbsp;that suits both concrete (in some sense) and abstract usage of the term.</p>
<h2><span id="Formalization" class="mw-headline">Formalization</span></h2>
<p>Algorithms are essential to the way computers process data. Many computer programs contain algorithms that detail the specific instructions a computer should perform&mdash;in a specific order&mdash;to carry out a specified task, such as calculating employees' paychecks or printing students' report cards. Thus, an algorithm can be considered to be any sequence of operations that can be simulated by a&nbsp;<a title="Turing reduction" href="https://en.wikipedia.org/wiki/Turing_reduction">Turing-complete</a>&nbsp;system. Authors who assert this thesis include Minsky (1967), Savage (1987) and Gurevich (2000):</p>
<blockquote>
<p>Minsky: "But we will also maintain, with Turing &hellip; that any procedure which could "naturally" be called effective, can, in fact, be realized by a (simple) machine. Although this may seem extreme, the arguments &hellip; in its favor are hard to refute".</p>
</blockquote>
<blockquote>
<p>Gurevich: &ldquo;&hellip; Turing's informal argument in favor of his thesis justifies a stronger thesis: every algorithm can be simulated by a Turing machine &hellip; according to Savage [1987], an algorithm is a computational process defined by a Turing machine".</p>
</blockquote>
<p>Turing machines can define computational processes that do not terminate. The informal definitions of algorithms generally require that the algorithm always terminates. This requirement renders the task of deciding whether a formal procedure is an algorithm impossible in the general case&mdash;due to a major theorem of&nbsp;<a title="Computability theory" href="https://en.wikipedia.org/wiki/Computability_theory">computability theory</a>&nbsp;known as the&nbsp;<a title="Halting problem" href="https://en.wikipedia.org/wiki/Halting_problem">halting problem</a>.</p>
<p>Typically, when an algorithm is associated with processing information, data can be read from an input source, written to an output device and stored for further processing. Stored data are regarded as part of the internal state of the entity performing the algorithm. In practice, the state is stored in one or more&nbsp;<a title="Data structure" href="https://en.wikipedia.org/wiki/Data_structure">data structures</a>.</p>
<p>For some of these computational process, the algorithm must be rigorously defined: specified in the way it applies in all possible circumstances that could arise. This means that any conditional steps must be systematically dealt with, case-by-case; the criteria for each case must be clear (and computable).</p>
<p>Because an algorithm is a precise list of precise steps, the order of computation is always crucial to the functioning of the algorithm. Instructions are usually assumed to be listed explicitly, and are described as starting "from the top" and going "down to the bottom"&mdash;an idea that is described more formally by&nbsp;<em><a title="Control flow" href="https://en.wikipedia.org/wiki/Control_flow">flow of control</a></em>.</p>
<p>So far, the discussion on the formalization of an algorithm has assumed the premises of&nbsp;<a title="Imperative programming" href="https://en.wikipedia.org/wiki/Imperative_programming">imperative programming</a>. This is the most common conception&mdash;one which attempts to describe a task in discrete, "mechanical" means. Unique to this conception of formalized algorithms is the&nbsp;<a class="mw-redirect" title="Assignment operation" href="https://en.wikipedia.org/wiki/Assignment_operation">assignment operation</a>, which sets the value of a variable. It derives from the intuition of "<a title="Memory" href="https://en.wikipedia.org/wiki/Memory">memory</a>" as a scratchpad. An example of such an assignment can be found below.</p>
<p>For some alternate conceptions of what constitutes an algorithm, see&nbsp;<a title="Functional programming" href="https://en.wikipedia.org/wiki/Functional_programming">functional programming</a>&nbsp;and&nbsp;<a title="Logic programming" href="https://en.wikipedia.org/wiki/Logic_programming">logic programming</a>.</p>
<h3><span id="Expressing_algorithms" class="mw-headline">Expressing algorithms</span></h3>
<p>Algorithms can be expressed in many kinds of notation, including&nbsp;<a title="Natural language" href="https://en.wikipedia.org/wiki/Natural_language">natural languages</a>,&nbsp;<a title="Pseudocode" href="https://en.wikipedia.org/wiki/Pseudocode">pseudocode</a>,&nbsp;<a title="Flowchart" href="https://en.wikipedia.org/wiki/Flowchart">flowcharts</a>,&nbsp;<a title="DRAKON" href="https://en.wikipedia.org/wiki/DRAKON">drakon-charts</a>,&nbsp;<a title="Programming language" href="https://en.wikipedia.org/wiki/Programming_language">programming languages</a>&nbsp;or&nbsp;<a title="Control table" href="https://en.wikipedia.org/wiki/Control_table">control tables</a>&nbsp;(processed by&nbsp;<a title="Interpreter (computing)" href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreters</a>). Natural language expressions of algorithms tend to be verbose and ambiguous, and are rarely used for complex or technical algorithms. Pseudocode, flowcharts,&nbsp;<a title="DRAKON" href="https://en.wikipedia.org/wiki/DRAKON">drakon-charts</a>&nbsp;and control tables are structured ways to express algorithms that avoid many of the ambiguities common in the statements based on natural language. Programming languages are primarily intended for expressing algorithms in a form that can be executed by a computer, but are also often used as a way to define or document algorithms.</p>
<p>There is a wide variety of representations possible and one can express a given&nbsp;<a title="Turing machine" href="https://en.wikipedia.org/wiki/Turing_machine">Turing machine</a>&nbsp;program as a sequence of machine tables, as flowcharts and&nbsp;<a title="DRAKON" href="https://en.wikipedia.org/wiki/DRAKON">drakon-charts</a>&nbsp;, or as a form of rudimentary&nbsp;<a title="Machine code" href="https://en.wikipedia.org/wiki/Machine_code">machine code</a>&nbsp;or&nbsp;<a class="mw-redirect" title="Assembly code" href="https://en.wikipedia.org/wiki/Assembly_code">assembly code</a>&nbsp;called "sets of quadruples".</p>
<p>Representations of algorithms can be classed into three accepted levels of Turing machine description, as follows:</p>
<dl>
<dt>1 High-level description</dt>
<dd>&ldquo;&hellip;prose to describe an algorithm, ignoring the implementation details. At this level, we do not need to mention how the machine manages its tape or head."</dd>
<dt>2 Implementation description</dt>
<dd>&ldquo;&hellip;prose used to define the way the Turing machine uses its head and the way that it stores data on its tape. At this level, we do not give details of states or transition function."</dd>
<dt>3 Formal description</dt>
<dd>Most detailed, "lowest level", gives the Turing machine's "state table".</dd>
</dl>
<p>For an example of the simple algorithm "Add m+n" described in all three levels, see&nbsp;<a title="Algorithm" href="https://en.wikipedia.org/wiki/Algorithm#Examples">Algorithm#Examples</a>.</p>
<h2><span id="Design" class="mw-headline">Design</span></h2>
<p>&nbsp;</p>
<p>Algorithm design refers to a method or a mathematical process for problem-solving and engineering algorithms. The design of algorithms is part of many solution theories of&nbsp;<a class="mw-redirect" title="Operation research" href="https://en.wikipedia.org/wiki/Operation_research">operation research</a>, such as&nbsp;<a title="Dynamic programming" href="https://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a>&nbsp;and&nbsp;<a class="mw-redirect" title="Divide and conquer algorithm" href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm">divide-and-conquer</a>. Techniques for designing and implementing algorithm designs are also called algorithm design patterns,&nbsp;with examples including the template method pattern and the decorator pattern.</p>
<p>One of the most important aspects of algorithm design lies in the creation of algorithm that has an efficient run-time, also known as its&nbsp;<a title="Big O notation" href="https://en.wikipedia.org/wiki/Big_O_notation">Big O</a>.</p>
<p>Typical steps in the development of algorithms:</p>
<ol>
<li>Problem definition</li>
<li>Development of a model</li>
<li>Specification of the algorithm</li>
<li>Designing an algorithm</li>
<li>Checking the&nbsp;<a title="Correctness (computer science)" href="https://en.wikipedia.org/wiki/Correctness_(computer_science)">correctness</a>&nbsp;of the algorithm</li>
<li>Analysis of algorithm</li>
<li>Implementation of algorithm</li>
<li>Program testing</li>
<li>Documentation preparation</li>
</ol>



