<p>In&nbsp;<a title="Mathematics" href="https://en.wikipedia.org/wiki/Mathematics">mathematics</a>&nbsp;and&nbsp;<a title="Computer science" href="https://en.wikipedia.org/wiki/Computer_science">computer science</a>, an&nbsp;<strong>algorithm</strong>&nbsp;is a finite sequence of&nbsp;<a title="Well-defined" href="https://en.wikipedia.org/wiki/Well-defined">well-defined</a>, computer-implementable instructions, typically to solve a class of problems or to perform a computation.&nbsp;Algorithms are always&nbsp;<a class="mw-redirect" title="Unambiguous" href="https://en.wikipedia.org/wiki/Unambiguous">unambiguous</a>&nbsp;and are used as specifications for performing&nbsp;<a title="Calculation" href="https://en.wikipedia.org/wiki/Calculation">calculations</a>,&nbsp;<a title="Data processing" href="https://en.wikipedia.org/wiki/Data_processing">data processing</a>,&nbsp;<a title="Automated reasoning" href="https://en.wikipedia.org/wiki/Automated_reasoning">automated reasoning</a>, and other tasks.</p>
<p>As an&nbsp;<a title="Effective method" href="https://en.wikipedia.org/wiki/Effective_method">effective method</a>, an algorithm can be expressed within a finite amount of space and time,&nbsp;and in a well-defined formal language&nbsp;for calculating a&nbsp;<a title="Function (mathematics)" href="https://en.wikipedia.org/wiki/Function_(mathematics)">function</a>.&nbsp;Starting from an initial state and initial input (perhaps&nbsp;<a title="Empty string" href="https://en.wikipedia.org/wiki/Empty_string">empty</a>),&nbsp;the instructions describe a&nbsp;<a title="Computation" href="https://en.wikipedia.org/wiki/Computation">computation</a>&nbsp;that, when&nbsp;<a title="Execution (computing)" href="https://en.wikipedia.org/wiki/Execution_(computing)">executed</a>, proceeds through a finite&nbsp;number of well-defined successive states, eventually producing "output"&nbsp;and terminating at a final ending state. The transition from one state to the next is not necessarily&nbsp;<a class="mw-redirect" title="Deterministic" href="https://en.wikipedia.org/wiki/Deterministic">deterministic</a>; some algorithms, known as&nbsp;<a class="mw-redirect" title="Randomized algorithms" href="https://en.wikipedia.org/wiki/Randomized_algorithms">randomized algorithms</a>, incorporate random input.</p>
<p>The concept of algorithm has existed since antiquity.&nbsp;<a title="Arithmetic" href="https://en.wikipedia.org/wiki/Arithmetic">Arithmetic</a>&nbsp;algorithms, such as a&nbsp;<a title="Division algorithm" href="https://en.wikipedia.org/wiki/Division_algorithm">division algorithm</a>, was used by ancient&nbsp;<a title="Babylonian mathematics" href="https://en.wikipedia.org/wiki/Babylonian_mathematics">Babylonian mathematicians</a>&nbsp;c. 2500 BC and&nbsp;<a class="mw-redirect" title="Egyptian mathematics" href="https://en.wikipedia.org/wiki/Egyptian_mathematics">Egyptian mathematicians</a>&nbsp;c. 1550 BC.&nbsp;<a title="Greek mathematics" href="https://en.wikipedia.org/wiki/Greek_mathematics">Greek mathematicians</a>&nbsp;later used algorithms in the&nbsp;<a title="Sieve of Eratosthenes" href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">sieve of Eratosthenes</a>&nbsp;for finding prime numbers,&nbsp;and the&nbsp;<a title="Euclidean algorithm" href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Euclidean algorithm</a>&nbsp;for finding the&nbsp;<a title="Greatest common divisor" href="https://en.wikipedia.org/wiki/Greatest_common_divisor">greatest common divisor</a>&nbsp;of two numbers.&nbsp;<a class="mw-redirect" title="Arabic mathematics" href="https://en.wikipedia.org/wiki/Arabic_mathematics">Arabic mathematicians</a>&nbsp;such as&nbsp;<a title="Al-Kindi" href="https://en.wikipedia.org/wiki/Al-Kindi">Al-Kindi</a>&nbsp;in the 9th century used&nbsp;<a class="mw-redirect" title="Cryptographic" href="https://en.wikipedia.org/wiki/Cryptographic">cryptographic</a>&nbsp;algorithms for&nbsp;<a class="mw-redirect" title="Code-breaking" href="https://en.wikipedia.org/wiki/Code-breaking">code-breaking</a>, based on&nbsp;<a title="Frequency analysis" href="https://en.wikipedia.org/wiki/Frequency_analysis">frequency analysis</a>.</p>
<p>The word&nbsp;<em>algorithm</em>&nbsp;itself is derived from the 9th-century&nbsp;<a class="mw-redirect" title="Persian people" href="https://en.wikipedia.org/wiki/Persian_people">Persian</a>&nbsp;mathematician&nbsp;<a title="Muhammad ibn Musa al-Khwarizmi" href="https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi">Muḥammad ibn Mūsā al-Khwārizmī</a>, Latinized&nbsp;<em>Algoritmi</em>.&nbsp;A partial formalization of what would become the modern concept of algorithm began with attempts to solve the&nbsp;<a title="Entscheidungsproblem" href="https://en.wikipedia.org/wiki/Entscheidungsproblem">Entscheidungsproblem</a>&nbsp;(decision problem) posed by&nbsp;<a title="David Hilbert" href="https://en.wikipedia.org/wiki/David_Hilbert">David Hilbert</a>&nbsp;in 1928. Later formalizations were framed as attempts to define "<a class="mw-redirect" title="Effective calculability" href="https://en.wikipedia.org/wiki/Effective_calculability">effective calculability</a>"&nbsp;or "effective method".<sup id="cite_ref-16" class="reference"><a href="https://en.wikipedia.org/wiki/Algorithm#cite_note-16">[16]</a></sup>&nbsp;Those formalizations included the&nbsp;<a title="Kurt G&ouml;del" href="https://en.wikipedia.org/wiki/Kurt_G%C3%B6del">G&ouml;del</a>&ndash;<a title="Jacques Herbrand" href="https://en.wikipedia.org/wiki/Jacques_Herbrand">Herbrand</a>&ndash;<a title="Stephen Cole Kleene" href="https://en.wikipedia.org/wiki/Stephen_Cole_Kleene">Kleene</a>&nbsp;<a title="Recursion (computer science)" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)">recursive functions</a>&nbsp;of 1930, 1934 and 1935,&nbsp;<a title="Alonzo Church" href="https://en.wikipedia.org/wiki/Alonzo_Church">Alonzo Church</a>'s&nbsp;<a title="Lambda calculus" href="https://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a>&nbsp;of 1936,&nbsp;<a class="mw-redirect" title="Emil Post" href="https://en.wikipedia.org/wiki/Emil_Post">Emil Post</a>'s&nbsp;<a class="mw-redirect" title="Formulation 1" href="https://en.wikipedia.org/wiki/Formulation_1">Formulation 1</a>&nbsp;of 1936, and&nbsp;<a title="Alan Turing" href="https://en.wikipedia.org/wiki/Alan_Turing">Alan Turing</a>'s&nbsp;<a class="mw-redirect" title="Turing machines" href="https://en.wikipedia.org/wiki/Turing_machines">Turing machines</a>&nbsp;of 1936&ndash;37 and 1939.</p>

</br>

<p><strong>Contents</strong></p>
<div class="toctitle" dir="ltr" lang="en">&nbsp;</div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Etymology"><span class="toctext">Etymology</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Informal_definition"><span class="toctext">Informal definition</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Formalization"><span class="toctext">Formalization</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Expressing_algorithms"><span class="toctext">Expressing algorithms</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="#Design"><span class="toctext">Design</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Implementation"><span class="toctext">Implementation</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Computer_algorithms"><span class="toctext">Computer algorithms</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#Examples"><span class="toctext">Examples</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#Algorithm_example"><span class="toctext">Algorithm example</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Euclid's_algorithm"><span class="toctext">Euclid's algorithm</span></a>
<ul>
<li class="toclevel-3 tocsection-11"><a href="#Computer_language_for_Euclid's_algorithm"><span class="toctext">Computer language for Euclid's algorithm</span></a></li>
<li class="toclevel-3 tocsection-12"><a href="#An_inelegant_program_for_Euclid's_algorithm"><span class="toctext">An inelegant program for Euclid's algorithm</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="#An_elegant_program_for_Euclid's_algorithm"><span class="toctext">An elegant program for Euclid's algorithm</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-14"><a href="#Testing_the_Euclid_algorithms"><span class="toctext">Testing the Euclid algorithms</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Measuring_and_improving_the_Euclid_algorithms"><span class="toctext">Measuring and improving the Euclid algorithms</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-16"><a href="#Algorithmic_analysis"><span class="toctext">Algorithmic analysis</span></a>
<ul>
<li class="toclevel-2 tocsection-17"><a href="#Formal_versus_empirical"><span class="toctext">Formal versus empirical</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Execution_efficiency"><span class="toctext">Execution efficiency</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="#Classification"><span class="toctext">Classification</span></a>
<ul>
<li class="toclevel-2 tocsection-20"><a href="#By_implementation"><span class="toctext">By implementation</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#By_design_paradigm"><span class="toctext">By design paradigm</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="#Optimization_problems"><span class="toctext">Optimization problems</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#By_field_of_study"><span class="toctext">By field of study</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#By_complexity"><span class="toctext">By complexity</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-25"><a href="#Continuous_algorithms"><span class="toctext">Continuous algorithms</span></a></li>
<li class="toclevel-1 tocsection-26"><a href="#Legal_issues"><span class="toctext">Legal issues</span></a></li>
<li class="toclevel-1 tocsection-27"><a href="#History:_Development_of_the_notion_of_%22algorithm%22"><span class="toctext">History: Development of the notion of "algorithm"</span></a>
<ul>
<li class="toclevel-2 tocsection-28"><a href="#Ancient_Near_East"><span class="toctext">Ancient Near East</span></a></li>
<li class="toclevel-2 tocsection-29"><a href="#Discrete_and_distinguishable_symbols"><span class="toctext">Discrete and distinguishable symbols</span></a></li>
<li class="toclevel-2 tocsection-30"><a href="#Manipulation_of_symbols_as_%22place_holders%22_for_numbers:_algebra"><span class="toctext">Manipulation of symbols as "place holders" for numbers: algebra</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="#Cryptographic_algorithms"><span class="toctext">Cryptographic algorithms</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="#Mechanical_contrivances_with_discrete_states"><span class="toctext">Mechanical contrivances with discrete states</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#Mathematics_during_the_19th_century_up_to_the_mid-20th_century"><span class="toctext">Mathematics during the 19th century up to the mid-20th century</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#Emil_Post_(1936)_and_Alan_Turing_(1936%E2%80%9337,_1939)"><span class="toctext">Emil Post (1936) and Alan Turing (1936&ndash;37, 1939)</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="#J.B._Rosser_(1939)_and_S.C._Kleene_(1943)"><span class="toctext">J.B. Rosser (1939) and S.C. Kleene (1943)</span></a></li>
<li class="toclevel-2 tocsection-36"><a href="#History_after_1950"><span class="toctext">History after 1950</span></a></li>
</ul>
</li>
</ul>
</br>

<h2><span id="Etymology" class="mw-headline">Etymology</span></h2>
<p>The word 'algorithm' has its roots in Latinizing the name of Persian mathematician&nbsp;<a title="Muhammad ibn Musa al-Khwarizmi" href="https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi">Muhammad ibn Musa al-Khwarizmi</a>&nbsp;in the first steps to&nbsp;<em>algorismus</em>.&nbsp;Al-Khwārizmī (<a title="Persian language" href="https://en.wikipedia.org/wiki/Persian_language">Persian</a>:&nbsp;<span dir="rtl" lang="fa">خوارزمی</span>&lrm;, c. 780&ndash;850) was a Persian mathematician,&nbsp;<a title="Astronomer" href="https://en.wikipedia.org/wiki/Astronomer">astronomer</a>,&nbsp;<a title="Geographer" href="https://en.wikipedia.org/wiki/Geographer">geographer</a>, and scholar in the&nbsp;<a title="House of Wisdom" href="https://en.wikipedia.org/wiki/House_of_Wisdom">House of Wisdom</a>&nbsp;in&nbsp;<a title="Baghdad" href="https://en.wikipedia.org/wiki/Baghdad">Baghdad</a>,&nbsp;whose name means 'the native of&nbsp;<a title="Khwarazm" href="https://en.wikipedia.org/wiki/Khwarazm">Khwarazm</a>', a region that was part of&nbsp;<a title="Greater Iran" href="https://en.wikipedia.org/wiki/Greater_Iran">Greater Iran</a>&nbsp;and is now in&nbsp;<a title="Uzbekistan" href="https://en.wikipedia.org/wiki/Uzbekistan">Uzbekistan</a>.</p>
<p>About 825, al-Khwarizmi wrote an&nbsp;<a class="mw-redirect" title="Arabic language" href="https://en.wikipedia.org/wiki/Arabic_language">Arabic language</a>&nbsp;treatise on the&nbsp;<a title="Hindu&ndash;Arabic numeral system" href="https://en.wikipedia.org/wiki/Hindu%E2%80%93Arabic_numeral_system">Hindu&ndash;Arabic numeral system</a>, which was translated into&nbsp;<a title="Latin" href="https://en.wikipedia.org/wiki/Latin">Latin</a>&nbsp;during the 12th century under the title&nbsp;<em>Algoritmi de numero Indorum</em>. This title means "Algoritmi on the numbers of the Indians", where "Algoritmi" was the translator's&nbsp;<a title="Latinisation of names" href="https://en.wikipedia.org/wiki/Latinisation_of_names">Latinization</a>&nbsp;of Al-Khwarizmi's name.&nbsp;Al-Khwarizmi was the most widely read mathematician in Europe in the late Middle Ages, primarily through another of his books, the&nbsp;<a class="mw-redirect" title="Al-Jabr" href="https://en.wikipedia.org/wiki/Al-Jabr">Algebra</a>. In late medieval Latin,&nbsp;<em>algorismus</em>, English '<a title="Algorism" href="https://en.wikipedia.org/wiki/Algorism">algorism</a>', the corruption of his name, simply meant the "decimal number system".&nbsp;In the 15th century, under the influence of the Greek word ἀ&rho;&iota;&theta;&mu;ό&sigmaf; 'number' (<em>cf.</em>&nbsp;'arithmetic'), the Latin word was altered to&nbsp;<em>algorithmus</em>, and the corresponding English term 'algorithm' is first attested in the 17th century; the modern sense was introduced in the 19th century.</p>
<p>In English, it was first used in about 1230 and then by&nbsp;<a title="Geoffrey Chaucer" href="https://en.wikipedia.org/wiki/Geoffrey_Chaucer">Chaucer</a>&nbsp;in 1391. English adopted the French term, but it wasn't until the late 19th century that "algorithm" took on the meaning that it has in modern English.</p>
<p>Another early use of the word is from 1240, in a manual titled&nbsp;<em>Carmen de Algorismo</em>&nbsp;composed by&nbsp;<a title="Alexander of Villedieu" href="https://en.wikipedia.org/wiki/Alexander_of_Villedieu">Alexandre de Villedieu</a>. It begins with:</p>
<blockquote class="templatequote">
<p><em>Haec algorismus ars praesens dicitur, in qua / Talibus Indorum fruimur bis quinque figuris.</em></p>
</blockquote>
<p>which translates to:</p>
<blockquote class="templatequote">
<p>Algorism is the art by which at present we use those Indian figures, which number two times five.</p>
</blockquote>
<p>The poem is a few hundred lines long and summarizes the art of calculating with the new style of Indian dice, or Talibus Indorum, or Hindu numerals.</p>
<h2><span id="Informal_definition" class="mw-headline">Informal definition</span></h2>
<div class="hatnote navigation-not-searchable">For a detailed presentation of the various points of view on the definition of "algorithm", see&nbsp;<a title="Algorithm characterizations" href="https://en.wikipedia.org/wiki/Algorithm_characterizations">Algorithm characterizations</a>.</div>
<p>An informal definition could be "a set of rules that precisely defines a sequence of operations",&nbsp;which would include all computer programs, including programs that do not perform numeric calculations, and (for example) any prescribed&nbsp;<a class="mw-redirect" title="Bureaucratic" href="https://en.wikipedia.org/wiki/Bureaucratic">bureaucratic</a>&nbsp;procedure.&nbsp;In general, a program is only an algorithm if it stops eventually.</p>
<p>A prototypical example of an algorithm is the&nbsp;<a title="Euclidean algorithm" href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Euclidean algorithm</a>, which is used to determine the maximum common divisor of two integers; an example (there are others) is described by the&nbsp;<a title="Flowchart" href="https://en.wikipedia.org/wiki/Flowchart">flowchart</a>&nbsp;above and as an example in a later section.</p>
<p><a href="https://en.wikipedia.org/wiki/Algorithm#CITEREFBoolosJeffrey1999">Boolos, Jeffrey &amp; 1974, 1999</a>&nbsp;offer an informal meaning of the word "algorithm" in the following quotation:</p>
<blockquote>
<p>No human being can write fast enough, or long enough, or small enough&dagger; ( &dagger;"smaller and smaller without limit &hellip; you'd be trying to write on molecules, on atoms, on electrons") to list all members of an enumerably infinite set by writing out their names, one after another, in some notation. But humans can do something equally useful, in the case of certain enumerably infinite sets: They can give&nbsp;<em>explicit instructions for determining the&nbsp;<strong>n</strong>th member of the set</em>, for arbitrary finite&nbsp;<em>n</em>. Such instructions are to be given quite explicitly, in a form in which&nbsp;<em>they could be followed by a computing machine</em>, or by a&nbsp;<em>human who is capable of carrying out only very elementary operations on symbols.</em></p>
</blockquote>
<p>An "<a title="Recursively enumerable set" href="https://en.wikipedia.org/wiki/Recursively_enumerable_set">enumerably infinite set</a>" is one whose elements can be put into one-to-one correspondence with the integers. Thus, Boolos and Jeffrey are saying that an algorithm implies instructions for a process that "creates" output integers from an&nbsp;<em>arbitrary</em>&nbsp;"input" integer or integers that, in theory, can be arbitrarily large. For example, an algorithm can be an algebraic equation such as&nbsp;<em>y = m + n</em>&nbsp;(i.e., two arbitrary "input variables"&nbsp;<em>m</em>&nbsp;and&nbsp;<em>n</em>&nbsp;that produce an output&nbsp;<em>y</em>), but various authors' attempts to define the notion indicate that the word implies much more than this, something on the order of (for the addition example):</p>
<dl>
<dd>Precise instructions (in language understood by "the computer")&nbsp;for a fast, efficient, "good"&nbsp;process that specifies the "moves" of "the computer" (machine or human, equipped with the necessary internally contained information and capabilities)&nbsp;to find, decode, and then process arbitrary input integers/symbols&nbsp;<em>m</em>&nbsp;and&nbsp;<em>n</em>, symbols&nbsp;<em>+</em>&nbsp;and&nbsp;<em>=</em>&nbsp;&hellip; and "effectively"&nbsp;produce, in a "reasonable" time,&nbsp;output-integer&nbsp;<em>y</em>&nbsp;at a specified place and in a specified format.</dd>
</dl>
<p>The concept of&nbsp;<em>algorithm</em>&nbsp;is also used to define the notion of&nbsp;<a title="Decidability (logic)" href="https://en.wikipedia.org/wiki/Decidability_(logic)">decidability</a>&mdash;a notion that is central for explaining how&nbsp;<a title="Formal system" href="https://en.wikipedia.org/wiki/Formal_system">formal systems</a>&nbsp;come into being starting from a small set of&nbsp;<a title="Axiom" href="https://en.wikipedia.org/wiki/Axiom">axioms</a>&nbsp;and rules. In&nbsp;<a title="Logic" href="https://en.wikipedia.org/wiki/Logic">logic</a>, the time that an algorithm requires to complete cannot be measured, as it is not apparently related to the customary physical dimension. From such uncertainties, that characterize ongoing work, stems the unavailability of a definition of&nbsp;<em>algorithm</em>&nbsp;that suits both concrete (in some sense) and abstract usage of the term.</p>
<h2><span id="Formalization" class="mw-headline">Formalization</span></h2>
<p>Algorithms are essential to the way computers process data. Many computer programs contain algorithms that detail the specific instructions a computer should perform&mdash;in a specific order&mdash;to carry out a specified task, such as calculating employees' paychecks or printing students' report cards. Thus, an algorithm can be considered to be any sequence of operations that can be simulated by a&nbsp;<a title="Turing reduction" href="https://en.wikipedia.org/wiki/Turing_reduction">Turing-complete</a>&nbsp;system. Authors who assert this thesis include Minsky (1967), Savage (1987) and Gurevich (2000):</p>
<blockquote>
<p>Minsky: "But we will also maintain, with Turing &hellip; that any procedure which could "naturally" be called effective, can, in fact, be realized by a (simple) machine. Although this may seem extreme, the arguments &hellip; in its favor are hard to refute".</p>
</blockquote>
<blockquote>
<p>Gurevich: &ldquo;&hellip; Turing's informal argument in favor of his thesis justifies a stronger thesis: every algorithm can be simulated by a Turing machine &hellip; according to Savage [1987], an algorithm is a computational process defined by a Turing machine".</p>
</blockquote>
<p>Turing machines can define computational processes that do not terminate. The informal definitions of algorithms generally require that the algorithm always terminates. This requirement renders the task of deciding whether a formal procedure is an algorithm impossible in the general case&mdash;due to a major theorem of&nbsp;<a title="Computability theory" href="https://en.wikipedia.org/wiki/Computability_theory">computability theory</a>&nbsp;known as the&nbsp;<a title="Halting problem" href="https://en.wikipedia.org/wiki/Halting_problem">halting problem</a>.</p>
<p>Typically, when an algorithm is associated with processing information, data can be read from an input source, written to an output device and stored for further processing. Stored data are regarded as part of the internal state of the entity performing the algorithm. In practice, the state is stored in one or more&nbsp;<a title="Data structure" href="https://en.wikipedia.org/wiki/Data_structure">data structures</a>.</p>
<p>For some of these computational process, the algorithm must be rigorously defined: specified in the way it applies in all possible circumstances that could arise. This means that any conditional steps must be systematically dealt with, case-by-case; the criteria for each case must be clear (and computable).</p>
<p>Because an algorithm is a precise list of precise steps, the order of computation is always crucial to the functioning of the algorithm. Instructions are usually assumed to be listed explicitly, and are described as starting "from the top" and going "down to the bottom"&mdash;an idea that is described more formally by&nbsp;<em><a title="Control flow" href="https://en.wikipedia.org/wiki/Control_flow">flow of control</a></em>.</p>
<p>So far, the discussion on the formalization of an algorithm has assumed the premises of&nbsp;<a title="Imperative programming" href="https://en.wikipedia.org/wiki/Imperative_programming">imperative programming</a>. This is the most common conception&mdash;one which attempts to describe a task in discrete, "mechanical" means. Unique to this conception of formalized algorithms is the&nbsp;<a class="mw-redirect" title="Assignment operation" href="https://en.wikipedia.org/wiki/Assignment_operation">assignment operation</a>, which sets the value of a variable. It derives from the intuition of "<a title="Memory" href="https://en.wikipedia.org/wiki/Memory">memory</a>" as a scratchpad. An example of such an assignment can be found below.</p>
<p>For some alternate conceptions of what constitutes an algorithm, see&nbsp;<a title="Functional programming" href="https://en.wikipedia.org/wiki/Functional_programming">functional programming</a>&nbsp;and&nbsp;<a title="Logic programming" href="https://en.wikipedia.org/wiki/Logic_programming">logic programming</a>.</p>
<h3><span id="Expressing_algorithms" class="mw-headline">Expressing algorithms</span></h3>
<p>Algorithms can be expressed in many kinds of notation, including&nbsp;<a title="Natural language" href="https://en.wikipedia.org/wiki/Natural_language">natural languages</a>,&nbsp;<a title="Pseudocode" href="https://en.wikipedia.org/wiki/Pseudocode">pseudocode</a>,&nbsp;<a title="Flowchart" href="https://en.wikipedia.org/wiki/Flowchart">flowcharts</a>,&nbsp;<a title="DRAKON" href="https://en.wikipedia.org/wiki/DRAKON">drakon-charts</a>,&nbsp;<a title="Programming language" href="https://en.wikipedia.org/wiki/Programming_language">programming languages</a>&nbsp;or&nbsp;<a title="Control table" href="https://en.wikipedia.org/wiki/Control_table">control tables</a>&nbsp;(processed by&nbsp;<a title="Interpreter (computing)" href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreters</a>). Natural language expressions of algorithms tend to be verbose and ambiguous, and are rarely used for complex or technical algorithms. Pseudocode, flowcharts,&nbsp;<a title="DRAKON" href="https://en.wikipedia.org/wiki/DRAKON">drakon-charts</a>&nbsp;and control tables are structured ways to express algorithms that avoid many of the ambiguities common in the statements based on natural language. Programming languages are primarily intended for expressing algorithms in a form that can be executed by a computer, but are also often used as a way to define or document algorithms.</p>
<p>There is a wide variety of representations possible and one can express a given&nbsp;<a title="Turing machine" href="https://en.wikipedia.org/wiki/Turing_machine">Turing machine</a>&nbsp;program as a sequence of machine tables, as flowcharts and&nbsp;<a title="DRAKON" href="https://en.wikipedia.org/wiki/DRAKON">drakon-charts</a>&nbsp;, or as a form of rudimentary&nbsp;<a title="Machine code" href="https://en.wikipedia.org/wiki/Machine_code">machine code</a>&nbsp;or&nbsp;<a class="mw-redirect" title="Assembly code" href="https://en.wikipedia.org/wiki/Assembly_code">assembly code</a>&nbsp;called "sets of quadruples".</p>
<p>Representations of algorithms can be classed into three accepted levels of Turing machine description, as follows:</p>
<dl>
<dt>1 High-level description</dt>
<dd>&ldquo;&hellip;prose to describe an algorithm, ignoring the implementation details. At this level, we do not need to mention how the machine manages its tape or head."</dd>
<dt>2 Implementation description</dt>
<dd>&ldquo;&hellip;prose used to define the way the Turing machine uses its head and the way that it stores data on its tape. At this level, we do not give details of states or transition function."</dd>
<dt>3 Formal description</dt>
<dd>Most detailed, "lowest level", gives the Turing machine's "state table".</dd>
</dl>
<p>For an example of the simple algorithm "Add m+n" described in all three levels, see&nbsp;<a title="Algorithm" href="https://en.wikipedia.org/wiki/Algorithm#Examples">Algorithm#Examples</a>.</p>
<h2><span id="Design" class="mw-headline">Design</span></h2>
<p>&nbsp;</p>
<p>Algorithm design refers to a method or a mathematical process for problem-solving and engineering algorithms. The design of algorithms is part of many solution theories of&nbsp;<a class="mw-redirect" title="Operation research" href="https://en.wikipedia.org/wiki/Operation_research">operation research</a>, such as&nbsp;<a title="Dynamic programming" href="https://en.wikipedia.org/wiki/Dynamic_programming">dynamic programming</a>&nbsp;and&nbsp;<a class="mw-redirect" title="Divide and conquer algorithm" href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm">divide-and-conquer</a>. Techniques for designing and implementing algorithm designs are also called algorithm design patterns,&nbsp;with examples including the template method pattern and the decorator pattern.</p>
<p>One of the most important aspects of algorithm design lies in the creation of algorithm that has an efficient run-time, also known as its&nbsp;<a title="Big O notation" href="https://en.wikipedia.org/wiki/Big_O_notation">Big O</a>.</p>
<p>Typical steps in the development of algorithms:</p>
<ol>
<li>Problem definition</li>
<li>Development of a model</li>
<li>Specification of the algorithm</li>
<li>Designing an algorithm</li>
<li>Checking the&nbsp;<a title="Correctness (computer science)" href="https://en.wikipedia.org/wiki/Correctness_(computer_science)">correctness</a>&nbsp;of the algorithm</li>
<li>Analysis of algorithm</li>
<li>Implementation of algorithm</li>
<li>Program testing</li>
<li>Documentation preparation</li>
</ol>

</br>

<h2><span id="Implementation" class="mw-headline">Implementation</span></h2>
<div class="thumb tright">
<div class="thumbinner"><a class="image" href="1.png"><img class="thumbimage" src="1.png" srcset="1.png" alt="" width="220" height="180" data-file-width="648" data-file-height="531" /></a>
<div class="thumbcaption">
<div class="magnify">&nbsp;</div>
<a class="mw-redirect" title="Logical NAND" href="https://en.wikipedia.org/wiki/Logical_NAND">Logical NAND</a>&nbsp;algorithm implemented electronically in&nbsp;<a class="mw-redirect" title="7400 series" href="https://en.wikipedia.org/wiki/7400_series">7400</a>&nbsp;chip</div>
<div class="thumbcaption">&nbsp;</div>
</div>
</div>
<p>Most algorithms are intended to be implemented as&nbsp;<a class="mw-redirect" title="Computer programs" href="https://en.wikipedia.org/wiki/Computer_programs">computer programs</a>. However, algorithms are also implemented by other means, such as in a&nbsp;<a class="mw-redirect" title="Biological neural network" href="https://en.wikipedia.org/wiki/Biological_neural_network">biological neural network</a>&nbsp;(for example, the&nbsp;<a title="Human brain" href="https://en.wikipedia.org/wiki/Human_brain">human brain</a>&nbsp;implementing&nbsp;<a title="Arithmetic" href="https://en.wikipedia.org/wiki/Arithmetic">arithmetic</a>&nbsp;or an insect looking for food), in an&nbsp;<a class="mw-redirect" title="Electrical circuit" href="https://en.wikipedia.org/wiki/Electrical_circuit">electrical circuit</a>, or in a mechanical device.</p>
<h2><span id="Computer_algorithms" class="mw-headline">Computer algorithms</span></h2>
<div class="thumb tright">
<div class="thumbinner"><a class="image" href="2.png"><img class="thumbimage" src="2.png" srcset="2.png" alt="" width="176" height="319" data-file-width="352" data-file-height="637" /></a>
<div class="thumbcaption">
<div class="magnify">&nbsp;</div>
Flowchart examples of the canonical&nbsp;<a title="Structured program theorem" href="https://en.wikipedia.org/wiki/Structured_program_theorem">B&ouml;hm-Jacopini structures</a>: the SEQUENCE (rectangles descending the page), the WHILE-DO and the IF-THEN-ELSE. The three structures are made of the primitive conditional GOTO (<code id="" class="mw-highlight mw-highlight-lang-text" dir="ltr">{{{1}}}</code>) (a diamond), the unconditional GOTO (rectangle), various assignment operators (rectangle), and HALT (rectangle). Nesting of these structures inside assignment-blocks result in complex diagrams (cf Tausworthe 1977:100, 114).</div>
<div class="thumbcaption">&nbsp;</div>
<div class="thumbcaption">&nbsp;</div>
</div>
</div>
<p>In&nbsp;<a class="mw-redirect" title="Computer systems" href="https://en.wikipedia.org/wiki/Computer_systems">computer systems</a>, an algorithm is basically an instance of&nbsp;<a title="Logic" href="https://en.wikipedia.org/wiki/Logic">logic</a>&nbsp;written in software by software developers, to be effective for the intended "target" computer(s) to produce&nbsp;<em>output</em>&nbsp;from given (perhaps null)&nbsp;<em>input</em>. An optimal algorithm, even running in old hardware, would produce faster results than a non-optimal (higher&nbsp;<a title="Time complexity" href="https://en.wikipedia.org/wiki/Time_complexity">time complexity</a>) algorithm for the same purpose, running in more efficient hardware; that is why algorithms, like computer hardware, are considered technology.</p>
<p><em>"Elegant" (compact) programs, "good" (fast) programs&nbsp;</em>: The notion of "simplicity and elegance" appears informally in&nbsp;<a title="Donald Knuth" href="https://en.wikipedia.org/wiki/Donald_Knuth">Knuth</a>&nbsp;and precisely in&nbsp;<a title="Gregory Chaitin" href="https://en.wikipedia.org/wiki/Gregory_Chaitin">Chaitin</a>:</p>
<dl>
<dd>Knuth: " &hellip; we want&nbsp;<em>good</em>&nbsp;algorithms in some loosely defined aesthetic sense. One criterion &hellip; is the length of time taken to perform the algorithm &hellip;. Other criteria are adaptability of the algorithm to computers, its simplicity and elegance, etc"</dd>
</dl>
<dl>
<dd>Chaitin: " &hellip; a program is 'elegant,' by which I mean that it's the smallest possible program for producing the output that it does"</dd>
</dl>
<p>Chaitin prefaces his definition with: "I'll show you can't prove that a program is 'elegant'"&mdash;such a proof would solve the&nbsp;<a title="Halting problem" href="https://en.wikipedia.org/wiki/Halting_problem">Halting problem</a>&nbsp;(ibid).</p>
<p><em>Algorithm versus function computable by an algorithm</em>: For a given function multiple algorithms may exist. This is true, even without expanding the available instruction set available to the programmer. Rogers observes that "It is ... important to distinguish between the notion of&nbsp;<em>algorithm</em>, i.e. procedure and the notion of&nbsp;<em>function computable by algorithm</em>, i.e. mapping yielded by procedure. The same function may have several different algorithms".</p>
<p>Unfortunately, there may be a tradeoff between goodness (speed) and elegance (compactness)&mdash;an elegant program may take more steps to complete a computation than one less elegant. An example that uses Euclid's algorithm appears below.</p>
<p><em>Computers (and computors), models of computation</em>: A computer (or human "computor") is a restricted type of machine, a "discrete deterministic mechanical device"&nbsp;that blindly follows its instructions.&nbsp;Melzak's and Lambek's primitive models&nbsp;reduced this notion to four elements: (i) discrete, distinguishable&nbsp;<em>locations</em>, (ii) discrete, indistinguishable&nbsp;<em>counters</em>&nbsp;(iii) an agent, and (iv) a list of instructions that are&nbsp;<em>effective</em>&nbsp;relative to the capability of the agent.</p>
<p>Minsky describes a more congenial variation of Lambek's "abacus" model in his "Very Simple Bases for&nbsp;<a title="Computability" href="https://en.wikipedia.org/wiki/Computability">Computability</a>".&nbsp;<a class="mw-redirect" title="Minsky machine" href="https://en.wikipedia.org/wiki/Minsky_machine">Minsky's machine</a>&nbsp;proceeds sequentially through its five (or six, depending on how one counts) instructions, unless either a conditional IF&ndash;THEN GOTO or an unconditional GOTO changes program flow out of sequence. Besides HALT, Minsky's machine includes three&nbsp;<em>assignment</em>&nbsp;(replacement, substitution)&nbsp;operations: ZERO (e.g. the contents of location replaced by 0: L &larr; 0), SUCCESSOR (e.g. L &larr; L+1), and DECREMENT (e.g. L &larr; L &minus; 1).&nbsp;Rarely must a programmer write "code" with such a limited instruction set. But Minsky shows (as do Melzak and Lambek) that his machine is&nbsp;<a class="mw-redirect" title="Turing complete" href="https://en.wikipedia.org/wiki/Turing_complete">Turing complete</a>&nbsp;with only four general&nbsp;<em>types</em>&nbsp;of instructions: conditional GOTO, unconditional GOTO, assignment/replacement/substitution, and HALT. However, a few different assignment instructions (e.g. DECREMENT, INCREMENT, and ZERO/CLEAR/EMPTY for a Minsky machine) are also required for Turing-completeness; their exact specification is somewhat up to the designer. The unconditional GOTO is a convenience; it can be constructed by initializing a dedicated location to zero e.g. the instruction " Z &larr; 0 "; thereafter the instruction IF Z=0 THEN GOTO xxx is unconditional.</p>
<p><em>Simulation of an algorithm: computer (computor) language</em>: Knuth advises the reader that "the best way to learn an algorithm is to try it . . . immediately take pen and paper and work through an example".&nbsp;But what about a simulation or execution of the real thing? The programmer must translate the algorithm into a language that the simulator/computer/computor can&nbsp;<em>effectively</em>&nbsp;execute. Stone gives an example of this: when computing the roots of a quadratic equation the computor must know how to take a square root. If they don't, then the algorithm, to be effective, must provide a set of rules for extracting a square root.</p>
<p>This means that the programmer must know a "language" that is effective relative to the target computing agent (computer/computor).</p>
<p>But what model should be used for the simulation? Van Emde Boas observes "even if we base&nbsp;<a title="Computational complexity theory" href="https://en.wikipedia.org/wiki/Computational_complexity_theory">complexity theory</a>&nbsp;on abstract instead of concrete machines, arbitrariness of the choice of a model remains. It is at this point that the notion of&nbsp;<em>simulation</em>&nbsp;enters".&nbsp;When speed is being measured, the instruction set matters. For example, the subprogram in Euclid's algorithm to compute the remainder would execute much faster if the programmer had a "<a title="Modular arithmetic" href="https://en.wikipedia.org/wiki/Modular_arithmetic">modulus</a>" instruction available rather than just subtraction (or worse: just Minsky's "decrement").</p>
<p><em>Structured programming, canonical structures</em>: Per the&nbsp;<a title="Church&ndash;Turing thesis" href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">Church&ndash;Turing thesis</a>, any algorithm can be computed by a model known to be&nbsp;<a class="mw-redirect" title="Turing complete" href="https://en.wikipedia.org/wiki/Turing_complete">Turing complete</a>, and per Minsky's demonstrations, Turing completeness requires only four instruction types&mdash;conditional GOTO, unconditional GOTO, assignment, HALT. Kemeny and Kurtz observe that, while "undisciplined" use of unconditional GOTOs and conditional IF-THEN GOTOs can result in "<a title="Spaghetti code" href="https://en.wikipedia.org/wiki/Spaghetti_code">spaghetti code</a>", a programmer can write structured programs using only these instructions; on the other hand "it is also possible, and not too hard, to write badly structured programs in a structured language".&nbsp;Tausworthe augments the three&nbsp;<a title="Structured program theorem" href="https://en.wikipedia.org/wiki/Structured_program_theorem">B&ouml;hm-Jacopini canonical structures</a>:&nbsp;SEQUENCE, IF-THEN-ELSE, and WHILE-DO, with two more: DO-WHILE and CASE.&nbsp;An additional benefit of a structured program is that it lends itself to&nbsp;<a class="mw-redirect" title="Proof of correctness" href="https://en.wikipedia.org/wiki/Proof_of_correctness">proofs of correctness</a>&nbsp;using&nbsp;<a title="Mathematical induction" href="https://en.wikipedia.org/wiki/Mathematical_induction">mathematical induction</a>.</p>
<p><em>Canonical flowchart symbols</em>: The graphical aide called a&nbsp;<a title="Flowchart" href="https://en.wikipedia.org/wiki/Flowchart">flowchart</a>, offers a way to describe and document an algorithm (and a computer program of one). Like the program flow of a Minsky machine, a flowchart always starts at the top of a page and proceeds down. Its primary symbols are only four: the directed arrow showing program flow, the rectangle (SEQUENCE, GOTO), the diamond (IF-THEN-ELSE), and the dot (OR-tie). The B&ouml;hm&ndash;Jacopini canonical structures are made of these primitive shapes. Sub-structures can "nest" in rectangles, but only if a single exit occurs from the superstructure. The symbols, and their use to build the canonical structures are shown in the diagram.</p>






